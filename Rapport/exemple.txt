#import "@preview/modern-report-umfds:0.1.2": umfds
#import "@preview/codly:1.2.0": *
#show: codly-init
#codly(stroke: .5pt + black)
#codly(number-format: none)
#import "@preview/codly-languages:0.1.6": *
#codly(languages: codly-languages)
#show: umfds.with(
  title: [Un d√©riv√© de Trivago en SOAP],
  authors: (
    "Corentin FAY",
  ),
  department: [Departement Informatique],
  date: datetime.today().display("[day] [month repr:long] [year]"),
  lang: "fr",
  abstract:[Ce Projet utilise SOAP et spring boot pour mettre en place un syst√®me de r√©servation de chambre d'un h√¥tel en passant par une agence.\

  Voici le github : #link("https://github.com/CorentinFW/RestRepo.git")[#underline[#text(
  fill: color.rgb(0,0,255),
  [Code du projet])]]]
)
#pagebreak()
#set outline.entry(fill: line(length: 100%, stroke: (thickness: 1pt, dash: "loosely-dotted")))
#outline(
  indent: auto,
  depth: 4
)
#pagebreak()
= PR√âSENTATION DU PROJET

== Contexte et Objectifs


Ce projet impl√©mente un syst√®me de r√©servation d'h√¥tels multi-agences bas√© sur
une architecture REST moderne et distribu√©e.

Le syst√®me permet √† des clients de :
  ‚Ä¢ Rechercher des chambres d'h√¥tel selon plusieurs crit√®res
  ‚Ä¢ Visualiser les offres agr√©g√©es de plusieurs agences
  ‚Ä¢ R√©server une chambre en temps r√©el
  ‚Ä¢ Consulter les r√©servations existantes
  ‚Ä¢ Voir les images des chambres

Architecture distribu√©e avec trois acteurs principaux :

  CLIENT (Interface graphique)
     ‚Üì ‚Üì
  AGENCES (Agr√©gateurs)
     ‚Üì ‚Üì ‚Üì
  H√îTELS (Fournisseurs)

Chaque composant est autonome et communique via des APIs REST standardis√©es.


== Technologies Utilis√©es


SPRING BOOT (Framework principal)

Spring Boot est le c≈ìur du projet, fournissant :
  ‚Ä¢ Configuration automatique des composants
  ‚Ä¢ Serveur Tomcat embarqu√© pour les APIs REST
  ‚Ä¢ Gestion des d√©pendances simplifi√©e
  ‚Ä¢ Profiles pour g√©rer plusieurs instances (paris, lyon, montpellier)

Avantages :
  ‚úì D√©marrage rapide sans configuration XML complexe
  ‚úì Convention over configuration
  ‚úì √âcosyst√®me riche (Web, Data, etc.)
  ‚úì Production-ready avec Actuator

Utilisation dans le projet :
  - \@SpringBootApplication initialise automatiquement l'application
  - \@RestController expose les endpoints HTTP
  - \@Value injecte les configurations depuis les fichiers .properties
  - Profiles Spring permettent de d√©marrer plusieurs instances avec des configs diff√©rentes


REST (Architecture de communication)

REST (Representational State Transfer) remplace SOAP pour :
  ‚Ä¢ Simplicit√© : JSON au lieu de XML
  ‚Ä¢ Standardisation : m√©thodes HTTP (GET, POST, PUT, DELETE)
  ‚Ä¢ Performance : messages plus l√©gers
  ‚Ä¢ Compatibilit√© : universel (navigateurs, mobiles, etc.)

Principes appliqu√©s :
  - Ressources identifi√©es par URLs (exemple: /api/hotel/chambres)
  - M√©thodes HTTP s√©mantiques (POST pour cr√©er, GET pour lire)
  - Stateless : chaque requ√™te est ind√©pendante
  - Format JSON pour les donn√©es

Une requ√™te typique contient l'adresse, les dates et la fourchette de prix en JSON.


H2 DATABASE (Base de donn√©es embarqu√©e)

H2 est une base de donn√©es Java l√©g√®re et performante :
  ‚Ä¢ Embarqu√©e : pas de serveur s√©par√© √† installer
  ‚Ä¢ Persistante : mode FILE pour sauvegarder sur disque
  ‚Ä¢ Compatible SQL : standard JDBC/JPA
  ‚Ä¢ Console web int√©gr√©e pour le d√©bogage

Configuration : l'URL de datasource pointe vers un fichier local et Hibernate
met √† jour automatiquement le sch√©ma de la base.

Avantages :
  ‚úì Installation zero (inclus dans le JAR)
  ‚úì Id√©al pour le d√©veloppement et les petits syst√®mes
  ‚úì Migration facile vers PostgreSQL/MySQL si besoin
  ‚úì Performances excellentes


SPRING DATA JPA (ORM)

JPA (Java Persistence API) avec Hibernate g√®re la persistance :
  ‚Ä¢ Mapping objet-relationnel automatique
  ‚Ä¢ Repositories pour abstraire les requ√™tes SQL
  ‚Ä¢ Transactions g√©r√©es automatiquement
  ‚Ä¢ Requ√™tes JPQL type-safe

Utilisation : Les annotations \@Entity sur les mod√®les d√©finissent les tables.
Les interfaces Repository h√©ritent de JpaRepository et Spring g√©n√®re automatiquement
les requ√™tes SQL. Par exemple, une m√©thode findByHotel() g√©n√®re automatiquement
la requ√™te SELECT correspondante.


RESTTEMPLATE (Client REST)

RestTemplate est le client HTTP de Spring pour appeler les APIs :
  ‚Ä¢ Configuration simple avec les URLs des services
  ‚Ä¢ Conversion automatique JSON ‚Üî Java (Jackson)
  ‚Ä¢ Gestion des erreurs HTTP
  ‚Ä¢ Support des timeouts

Utilisation : RestTemplate envoie les requ√™tes HTTP, s√©rialise automatiquement
les objets Java en JSON, puis d√©s√©rialise la r√©ponse JSON en objets Java.
Tout est transparent pour le d√©veloppeur.


JAVAX SWING (Interface graphique)

Swing est la biblioth√®que Java pour cr√©er des interfaces graphiques :
  ‚Ä¢ Composants riches (JTable, JButton, JTextField, etc.)
  ‚Ä¢ Event-driven programming (listeners)
  ‚Ä¢ Cross-platform (m√™me interface sur Windows/Linux/Mac)
  ‚Ä¢ Int√©gration native avec Java

Composants utilis√©s :
  - JFrame : fen√™tre principale
  - JTable : tableau des r√©sultats
  - JPanel : organisation des zones
  - JButton : actions (rechercher, r√©server)
  - JDialog : popups (images, confirmations)
  - JTextArea : console de logs

Architecture Swing :
  - Event Dispatch Thread (EDT) pour l'UI
  - SwingUtilities.invokeLater() pour les updates thread-safe
  - ActionListener pour r√©agir aux clics
  - MouseListener pour les interactions avanc√©es


MAVEN (Gestion de projet)

Maven g√®re la construction du projet :
  ‚Ä¢ D√©pendances d√©clar√©es dans pom.xml
  ‚Ä¢ Compilation : mvn clean install
  ‚Ä¢ Packaging : cr√©ation des JARs
  ‚Ä¢ Cycles de vie standardis√©s

Structure : Chaque module (Hotellerie, Agence, Client) a son propre pom.xml
d√©clarant ses d√©pendances. Maven t√©l√©charge automatiquement toutes les
biblioth√®ques n√©cessaires et g√®re les versions.



= MODULE H√îTEL

== R√¥le et Responsabilit√©s

L'h√¥tel est le fournisseur de base du syst√®me. Il :
  ‚Ä¢ G√®re son inventaire de chambres
  ‚Ä¢ V√©rifie la disponibilit√© en temps r√©el
  ‚Ä¢ Cr√©e et stocke les r√©servations
  ‚Ä¢ Sert les images des chambres
  ‚Ä¢ Maintient sa propre base de donn√©es

Chaque h√¥tel est une application Spring Boot ind√©pendante avec :
  - Son propre port (8082, 8083, 8084)
  - Sa propre base H2
  - Ses propres chambres et tarifs
  - Son profil Spring (paris, lyon, montpellier)


== Impl√©mentation REST

ENDPOINTS EXPOS√âS

L'h√¥tel expose 5 endpoints REST principaux :

1. GET /api/hotel/info
   Retourne les informations de l'h√¥tel (nom, adresse, √©toiles)

2. POST /api/hotel/chambres/rechercher
   Recherche les chambres disponibles selon les crit√®res re√ßus (dates, prix, lits)

3. POST /api/hotel/reservations/creer
   Cr√©e une nouvelle r√©servation et retourne un ID de confirmation

4. GET /api/hotel/chambres/reservees
   Liste toutes les chambres actuellement r√©serv√©es avec les infos clients

5. GET /api/hotel/images/{imageId}
   T√©l√©charge l'image d'une chambre au format binaire (JPEG/PNG)


LOGIQUE M√âTIER CL√âS

Recherche de chambres disponibles :
  1. Filtrer les chambres par crit√®res statiques (prix, lits)
  2. Pour chaque chambre, interroger la BDD pour v√©rifier l'absence de r√©servation
  3. Algorithme de d√©tection de conflit :
     Une r√©servation existe si :
     (dateArriveeResa <= dateDepart) ET (dateDepartResa >= dateArrivee)
  4. Retourner uniquement les chambres sans conflit

Cr√©ation de r√©servation :
  1. V√©rifier l'existence de la chambre
  2. V√©rifier l'absence de conflit (requ√™te JPA)
  3. Cr√©er l'entit√© Reservation
  4. Sauvegarder dans H2 (commit automatique)
  5. Retourner l'ID de r√©servation

Gestion des images :
  1. Mapping : chaque h√¥tel a une image (Hotelle1.png, Hotelle2.png, etc.)
  2. Toutes les chambres d'un h√¥tel partagent la m√™me image
  3. Le contr√¥leur lit le fichier depuis Hotellerie/Image/
  4. Retourne en byte[] avec Content-Type: image/png


== Configuration Multi-Instances

Chaque h√¥tel utilise un profil Spring diff√©rent pour personnaliser sa configuration.

Exemple pour Paris : port 8082, base de donn√©es paris-db, nom "H√¥tel de Paris"
Exemple pour Lyon : port 8083, base de donn√©es lyon-db, nom "H√¥tel de Lyon"

Le d√©marrage se fait avec l'option --spring.profiles.active qui charge le bon
fichier de configuration. Cela permet de lancer plusieurs instances du m√™me
code avec des param√®tres diff√©rents (port, BDD, donn√©es m√©tier).


== Persistance des Donn√©es

INITIALISATION AU D√âMARRAGE

Le HotelService s'ex√©cute au d√©marrage (\@PostConstruct) :
  1. V√©rifier si l'h√¥tel existe dans H2
  2. Si non, cr√©er l'entit√© Hotel
  3. Pour chaque chambre par d√©faut :
     a. V√©rifier si elle existe
     b. Si non, cr√©er l'entit√© Chambre
  4. Les r√©servations existantes sont charg√©es automatiquement par JPA

MOD√àLE DE DONN√âES

Trois entit√©s principales avec annotations JPA :

‚Ä¢ Hotel : contient id, nom, adresse, √©toiles et une liste de chambres
  Relation : un h√¥tel poss√®de plusieurs chambres

‚Ä¢ Chambre : contient id, num√©ro, prix par nuit, nombre de lits, URL image
  Relations : appartient √† un h√¥tel, peut avoir plusieurs r√©servations

‚Ä¢ Reservation : contient id, dates d'arriv√©e/d√©part, nom et pr√©nom du client
  Relation : associ√©e √† une chambre

Les annotations JPA d√©finissent les relations :
  - \@OneToMany : un vers plusieurs (h√¥tel ‚Üí chambres)
  - \@ManyToOne : plusieurs vers un (chambres ‚Üí h√¥tel)
  - Cascade : suppression en cascade si n√©cessaire
  - FetchType : LAZY pour optimiser les requ√™tes



= MODULE AGENCE

== R√¥le d'Agr√©gateur


L'agence est un interm√©diaire intelligent qui :
  ‚Ä¢ Se connecte √† plusieurs h√¥tels simultan√©ment
  ‚Ä¢ Agr√®ge les offres dans une r√©ponse unifi√©e
  ‚Ä¢ Applique son coefficient tarifaire sur chaque chambre
  ‚Ä¢ Route les r√©servations vers le bon h√¥tel
  ‚Ä¢ Offre une API unique au client

Architecture multi-agences :
  Le syst√®me supporte plusieurs agences en parall√®le :

  AGENCE 1 "Paris Voyages" (port 8081, coef 1.15)
    ‚îú‚îÄ> H√¥tel Paris (8082)
    ‚îî‚îÄ> H√¥tel Lyon (8083)

  AGENCE 2 "Sud R√©servations" (port 8085, coef 1.20)
    ‚îú‚îÄ> H√¥tel Lyon (8083)    [h√¥tel partag√©]
    ‚îî‚îÄ> H√¥tel Montpellier (8084)

Avantages :
  ‚úì Le client voit toutes les offres via une seule recherche
  ‚úì Les h√¥tels partag√©s apparaissent avec diff√©rents prix
  ‚úì Chaque agence a sa propre politique tarifaire
  ‚úì R√©silience : une agence peut tomber sans impacter les autres


== Impl√©mentation REST

ENDPOINTS EXPOS√âS

L'agence expose 4 endpoints REST :

1. GET /api/agence/ping
   Test de connexion pour v√©rifier que l'agence est op√©rationnelle

2. POST /api/agence/chambres/rechercher
   Recherche agr√©g√©e : interroge tous les h√¥tels et fusionne les r√©sultats

3. POST /api/agence/reserver
   D√©l√®gue la r√©servation √† l'h√¥tel concern√© en utilisant son URL

4. GET /api/agence/chambres/reservees
   R√©cup√®re toutes les r√©servations via cette agence depuis tous ses h√¥tels


ALGORITHME D'AGR√âGATION

M√©thode rechercherChambres() du AgenceService :

  1. Cr√©er une liste vide pour les r√©sultats
  2. Pour chaque h√¥tel configur√© :
     a. Appeler son API REST en parall√®le (threads)
     b. R√©cup√©rer List<ChambreDTO>
     c. Pour chaque chambre :
        - Multiplier le prix par le coefficient de l'agence
        - Ajouter le champ "agenceNom"
     d. Ajouter √† la liste de r√©sultats
  3. Attendre que tous les threads se terminent
  4. Retourner la liste fusionn√©e

Exemple :
  H√¥tel Lyon retourne une chambre √† 100‚Ç¨
  Agence "Paris Voyages" (coef 1.15) : 100‚Ç¨ √ó 1.15 = 115‚Ç¨
  Agence "Sud R√©servations" (coef 1.20) : 100‚Ç¨ √ó 1.20 = 120‚Ç¨

  Le client voit deux lignes pour la m√™me chambre physique,
  avec des prix diff√©rents selon l'agence.


CLIENT REST : MultiHotelRestClient

Cette classe g√®re les communications avec les h√¥tels. Elle utilise RestTemplate
pour appeler les APIs REST de chaque h√¥tel configur√©.

Les URLs des h√¥tels sont inject√©es depuis les fichiers de configuration via
\@Value. La m√©thode de recherche envoie la requ√™te √† chaque h√¥tel et retourne
la liste fusionn√©e des chambres.

Gestion des erreurs robuste :
  - Timeout : si un h√¥tel ne r√©pond pas en 5s, il est ignor√©
  - Erreur HTTP : logg√©e et le syst√®me continue avec les autres h√¥tels
  - Pas de propagation : une erreur sur un h√¥tel n'impacte pas les autres


== Configuration

Chaque agence a son propre fichier de configuration avec :
  - Port unique (8081 pour Paris Voyages, 8085 pour Sud R√©servations)
  - Nom de l'agence
  - Coefficient tarifaire (1.15 ou 1.20)
  - URLs des h√¥tels connect√©s

Le coefficient est inject√© dans le code via \@Value et appliqu√© automatiquement
sur chaque prix de chambre r√©cup√©r√© des h√¥tels.


#pagebreak()
= MODULE CLIENT

== Interface Graphique Swing

Le client est une application desktop avec interface graphique compl√®te.

=== ARCHITECTURE SWING

ClientGUI h√©rite de JFrame et organise l'interface en zones

Composants principaux :

1. JTable pour les r√©sultats :
   - DefaultTableModel pour g√©rer les donn√©es
   - Colonnes : N¬∞, H√¥tel, Ville, Prix, Lits, Agence, Image
   - Tri par colonne (TableRowSorter)
   - S√©lection de ligne pour r√©server

2. JTextField pour les crit√®res :
   - Ville, dates, prix min/max, nombre de lits
   - Validation des entr√©es
   - Bouton "Rechercher" avec ActionListener

3. JTextArea pour la console :
   - Logs horodat√©s [HH:mm:ss]
   - Auto-scroll vers le bas
   - Police monospace
   - Couleurs avec HTML

4. JLabel pour le statut :
   - Indicateur de connexion aux agences
   - Mise √† jour en temps r√©el


=== GESTION DES √âV√âNEMENTS

Les boutons utilisent des ActionListener pour r√©agir aux clics utilisateur.
Lors d'une recherche, les crit√®res sont r√©cup√©r√©s des champs de saisie, puis
un thread s√©par√© appelle le service REST pour √©viter de bloquer l'interface.

Le double-clic sur une ligne du tableau d√©clenche la r√©servation de la chambre
s√©lectionn√©e via un MouseListener.

Thread-safety cruciale :
  - Appels REST dans des threads s√©par√©s (√©vite de geler l'UI)
  - Mises √† jour de l'interface toujours dans l'Event Dispatch Thread (EDT)
  - Utilisation de SwingUtilities.invokeLater() pour la synchronisation
  - Synchronisation sur les donn√©es partag√©es entre threads


=== AFFICHAGE DES IMAGES

Chaque chambre a une ic√¥ne üñºÔ∏è cliquable dans le tableau :

1. D√©tection du clic sur la colonne "Image"
2. R√©cup√©ration de l'URL de l'image depuis le DTO
3. T√©l√©chargement via RestTemplate :
   byte[] imageBytes = restTemplate.getForObject(imageUrl, byte[].class);
4. Conversion en ImageIcon :
   ImageIcon icon = new ImageIcon(imageBytes);
5. Affichage dans une JDialog modale :
   JDialog dialog = new JDialog(this, "Chambre " + numero, true);
   dialog.add(new JLabel(icon));
   dialog.pack();
   dialog.setVisible(true);

Optimisation : cache des images d√©j√† t√©l√©charg√©es pour √©viter les requ√™tes r√©p√©t√©es.


== Client REST Multi-Agences

MultiAgenceRestClient g√®re les connexions √† plusieurs agences simultan√©ment.

Les URLs des agences sont inject√©es depuis la configuration. Au d√©marrage,
toutes les URLs sont collect√©es dans une liste.

La m√©thode de recherche interroge chaque agence s√©quentiellement, accumule
tous les r√©sultats et les retourne fusionn√©s. Si une agence ne r√©pond pas,
elle est logg√©e comme indisponible mais les autres continuent √† fonctionner.

Fonctionnalit√©s :
  ‚Ä¢ Fusion automatique des r√©sultats de toutes les agences
  ‚Ä¢ Gestion des erreurs par agence (isolation des pannes)
  ‚Ä¢ Test de connexion au d√©marrage
  ‚Ä¢ Affichage du statut de connexion dans l'interface


=== CONSOLE DE LOGS

Format des logs : timestamp entre crochets, ic√¥ne, message

Ic√¥nes utilis√©es :
  ‚úì  Succ√®s       üîç Recherche
  ‚úó  Erreur       üìù R√©servation
  ‚ö†  Avertissement  ‚ÑπÔ∏è  Information

La m√©thode log() formate les messages avec horodatage et les ajoute √† la zone
de texte. L'auto-scroll garantit que le dernier log est toujours visible.

Exemples typiques :
  - Lancement d'une recherche avec crit√®res
  - Nombre de chambres trouv√©es
  - Confirmation de r√©servation avec ID
  - Erreurs d√©taill√©es en cas de probl√®me



= BASE DE DONN√âES H2

== Architecture de Persistance

=== CHOIX DE H2

H2 a √©t√© choisi pour :
  ‚úì Embarquabilit√© : pas de serveur s√©par√©
  ‚úì L√©g√®ret√© : 2 MB, parfait pour ce type de projet
  ‚úì Persistance : mode FILE pour sauvegarder sur disque
  ‚úì Compatibilit√© : SQL standard, migration facile vers PostgreSQL/MySQL
  ‚úì Performance : excellent pour des volumes moyens

Configuration : Le mode FILE sauvegarde les donn√©es dans des fichiers locaux.
L'option ddl-auto=update fait qu'Hibernate cr√©e automatiquement les tables au
premier d√©marrage et les met √† jour si le mod√®le change, sans jamais supprimer
de donn√©es.


=== SCH√âMA DE DONN√âES

TABLE HOTEL
  id (PK)       BIGINT          Identifiant unique
  nom           VARCHAR(255)     Nom de l'h√¥tel
  adresse       VARCHAR(255)     Ville
  etoiles       INT              Nombre d'√©toiles (1-5)

TABLE CHAMBRE
  id (PK)       BIGINT          Identifiant unique
  numero        INT              Num√©ro de chambre
  prix_nuit     DOUBLE           Prix par nuit
  nombre_lits   INT              Nombre de lits
  image_url     VARCHAR(500)     URL de l'image
  hotel_id (FK) BIGINT           R√©f√©rence vers HOTEL

TABLE RESERVATION
  id (PK)       BIGINT          Identifiant unique
  date_arrivee  DATE             Date d'arriv√©e
  date_depart   DATE             Date de d√©part
  nom_client    VARCHAR(100)     Nom du client
  prenom_client VARCHAR(100)     Pr√©nom du client
  chambre_id (FK) BIGINT         R√©f√©rence vers CHAMBRE

Relations :
  HOTEL 1 ‚îÄ‚îÄ< N CHAMBRE
  CHAMBRE 1 ‚îÄ‚îÄ< N RESERVATION

Contraintes :
  - PRIMARY KEY sur tous les id
  - FOREIGN KEY avec ON DELETE CASCADE
  - INDEX sur date_arrivee et date_depart pour optimiser les recherches


== Spring Data JPA

=== REPOSITORIES

Spring Data JPA g√©n√®re automatiquement les impl√©mentations des repositories.

L'interface HotelRepository d√©clare une m√©thode findByNom() et Spring g√©n√®re
automatiquement la requ√™te SQL correspondante (SELECT WHERE nom = ?).

L'interface ChambreRepository h√©rite de m√©thodes standards (save, findById,
findAll, delete, count) plus des m√©thodes personnalis√©es comme findByHotel().

M√©thodes h√©rit√©es automatiquement :
  - save() pour INSERT ou UPDATE
  - findById() pour SELECT par cl√© primaire
  - findAll() pour r√©cup√©rer tout
  - delete() pour supprimer
  - count() pour compter


=== REQU√äTES PERSONNALIS√âES

Pour les requ√™tes complexes, on utilise \@Query avec JPQL (Java Persistence Query Language).

Exemple : trouver les chambres disponibles n√©cessite une requ√™te qui r√©cup√®re
les chambres d'un h√¥tel en excluant celles ayant une r√©servation qui chevauche
les dates demand√©es.

L'algorithme de chevauchement v√©rifie si une r√©servation existe avec :
  date d'arriv√©e r√©servation ‚â§ date de d√©part demand√©e
  ET date de d√©part r√©servation ‚â• date d'arriv√©e demand√©e

Hibernate traduit automatiquement le JPQL en SQL natif pour H2.


=== GESTION DES TRANSACTIONS

L'annotation \@Transactional sur les m√©thodes de service active la gestion
automatique des transactions.

Pour les lectures seules, on utilise readOnly=true pour permettre des
optimisations. Pour les √©critures (r√©servations), on peut sp√©cifier le niveau
d'isolation pour √©viter les conflits en cas d'acc√®s concurrents.

Avantages :
  Commit/rollback automatique
  Gestion des deadlocks
  Isolation pour √©viter les conflits concurrents
  Propagation pour g√©rer les transactions imbriqu√©es


=== INITIALISATION DES DONN√âES

Au d√©marrage, le HotelService s'ex√©cute automatiquement gr√¢ce √† \@PostConstruct.

Processus :
  1. V√©rifier si l'h√¥tel existe dans la base, sinon le cr√©er
  2. Pour chaque chambre par d√©faut (101 √† 105) :
     - V√©rifier si elle existe d√©j√†
     - Si non, cr√©er la chambre avec ses attributs (prix, lits, URL image)
  3. Les r√©servations existantes sont automatiquement charg√©es par JPA

Ce syst√®me garantit que chaque h√¥tel a toujours ses donn√©es de base, m√™me au
premier d√©marrage, tout en pr√©servant les r√©servations existantes.



= SCRIPTS DE D√âMARRAGE

== Scripts Principaux


Quatre scripts essentiels pour l'exploitation :

1. rest-all-restart.sh
   ‚Üí Red√©marre tout le syst√®me (BDD + Agences + H√¥tels + Client)
   Usage : ./rest-all-restart.sh
   Cas d'usage : premier d√©marrage, reset complet

2. rest-restart.sh
   ‚Üí Red√©marre Agences + H√¥tels (conserve la BDD)
   Usage : ./rest-restart.sh
   Cas d'usage : modifications du code backend

3. rest-client.sh
   ‚Üí Lance uniquement l'interface graphique
   Usage : ./rest-client.sh
   Cas d'usage : red√©marrer le client sans toucher au backend

4. arreter-services.sh
   ‚Üí Arr√™te proprement tous les services
   Usage : ./arreter-services.sh
   Cas d'usage : arr√™t du syst√®me

Architecture des scripts :
  rest-all-restart.sh
    ‚îú‚îÄ> Supprime les BDD (rm -rf Hotellerie/data/\*.mv.db)
    ‚îú‚îÄ> Lance start-systeme-maven.sh
    ‚îî‚îÄ> Lance rest-client.sh

  rest-restart.sh
    ‚îú‚îÄ> Conserve les BDD
    ‚îú‚îÄ> Lance start-systeme-maven.sh
    ‚îî‚îÄ> Lance rest-client.sh

  start-systeme-maven.sh
    ‚îú‚îÄ> Compile les 3 modules (mvn clean install)
    ‚îú‚îÄ> Lance les 3 h√¥tels (mvn spring-boot:run avec profil)
    ‚îî‚îÄ> Lance les 2 agences


== D√©marrage D√©taill√©


WORKFLOW DE start-systeme-maven.sh

Le script compile d'abord les trois modules (Hotellerie, Agence, Client) avec
Maven en sautant les tests.

Ensuite, il d√©marre les trois h√¥tels en arri√®re-plan avec leurs profils
respectifs (paris, lyon, montpellier).

Apr√®s 20 secondes d'attente (temps pour les h√¥tels de d√©marrer compl√®tement),
il lance les deux agences avec leurs profils (agence1, agence2).

Tous les logs sont redirig√©s vers le dossier logs/ avec un fichier par service
(hotel-paris.log, agence1.log, etc.).

V√©rification : on peut tester avec curl sur les endpoints /api/hotel/info et
/api/agence/ping pour confirmer que tout fonctionne.


WORKFLOW DE rest-client.sh

Le script compile le module Client, d√©sactive le mode headless Java (pour
permettre l'affichage graphique), puis lance l'application avec Maven.

L'interface Swing se lance automatiquement et les logs sont sauvegard√©s dans
logs/client-gui.log.



= √âVOLUTIONS FUTURES


== S√©curit√©

‚Ä¢ AUTHENTIFICATION JWT
  - Token d'acc√®s pour chaque client
  - Refresh token pour renouveler les sessions
  - Stockage s√©curis√© des tokens
  - Expiration automatique apr√®s inactivit√©

‚Ä¢ HTTPS
  - Certificats SSL pour chiffrer les communications
  - Configuration avec Let's Encrypt
  - Redirection automatique HTTP ‚Üí HTTPS
  - HSTS (HTTP Strict Transport Security)

‚Ä¢ AUTORISATION
  - R√¥les : CLIENT, AGENCE, HOTEL, ADMIN
  - Permissions granulaires par endpoint
  - Spring Security pour g√©rer les acc√®s
  - OAuth2 pour l'int√©gration avec des fournisseurs externes

‚Ä¢ PROTECTION DES DONN√âES
  - Hachage des mots de passe avec BCrypt
  - Chiffrement des donn√©es sensibles en BDD
  - Conformit√© RGPD (droit √† l'oubli, export des donn√©es)
  - Rate limiting pour √©viter les abus


== Infrastructure


‚Ä¢ CONTAINERISATION
  - Dockerfile pour chaque module
  - Docker Compose pour orchestrer localement
  - Images optimis√©es (multi-stage builds)
  - Volumes pour la persistance des BDD

‚Ä¢ CI/CD
  - Pipeline Jenkins ou GitLab CI
  - Tests automatiques √† chaque commit
  - D√©ploiement automatique en staging/production
  - Rollback automatique en cas d'√©chec

‚Ä¢ BASE DE DONN√âES EXTERNE
  - Migration vers PostgreSQL pour la production
  - R√©plication master-slave pour la haute disponibilit√©
  - Backups automatiques quotidiens
  - Restauration rapide en cas de panne


== Tests


‚Ä¢ TESTS UNITAIRES
  - JUnit 5 pour les services
  - Mockito pour mocker les d√©pendances
  - Couverture de code > 80%
  - Tests param√©tr√©s pour diff√©rents sc√©narios

‚Ä¢ TESTS D'INT√âGRATION
  - \@SpringBootTest pour tester l'application compl√®te
  - MockMvc pour tester les controllers REST
  - TestContainers pour H2/PostgreSQL en isolation
  - Fixtures pour les donn√©es de test

‚Ä¢ TESTS DE CHARGE
  - JMeter pour simuler 1000+ utilisateurs simultan√©s
  - Gatling pour des sc√©narios r√©alistes
  - Analyse des temps de r√©ponse sous charge
  - Identification des goulots d'√©tranglement

‚Ä¢ TESTS END-TO-END
  - Selenium pour automatiser l'UI Swing
  - Sc√©narios complets (recherche ‚Üí r√©servation ‚Üí confirmation)
  - Tests de non-r√©gression
  - Tests cross-platform (Windows, Linux, Mac)



= CONCLUSION

== Bilan Technique


Ce projet d√©montre une ma√Ætrise compl√®te de l'√©cosyst√®me Spring Boot et
de l'architecture REST moderne.

=== TECHNOLOGIES MA√éTRIS√âES

Spring Boot : framework principal, configuration, profiles
REST : architecture, endpoints, s√©rialisation JSON
Spring Data JPA : ORM, repositories, transactions
H2 Database : persistance, SQL, migrations
RestTemplate : client REST, gestion d'erreurs
Swing : interface graphique, √©v√©nements, threading
Maven : build, d√©pendances, cycles de vie
Shell scripting : automatisation, d√©ploiement

=== CONCEPTS APPLIQU√âS

Architecture microservices : modules ind√©pendants
Agr√©gation de donn√©es : fusion multi-sources
Persistance transactionnelle : int√©grit√© des donn√©es
Multi-tenancy : plusieurs instances avec configurations diff√©rentes
Thread-safety : EDT Swing, appels asynchrones
Gestion d'erreurs : fallback, retry, logs
S√©paration des responsabilit√©s : contr√¥leurs, services, repositories


== Points Forts du Projet


‚Ä¢ ARCHITECTURE MODULAIRE
  Chaque composant (H√¥tel, Agence, Client) est ind√©pendant et peut √©voluer
  s√©par√©ment. Ajout d'un nouvel h√¥tel = nouvelle instance avec configuration.

‚Ä¢ PERSISTANCE FIABLE
  Les r√©servations survivent aux red√©marrages gr√¢ce √† H2 en mode FILE.
  Pas de perte de donn√©es, m√™me en cas de crash.

‚Ä¢ EXP√âRIENCE UTILISATEUR
  Interface graphique moderne avec console de logs, visualisation d'images,
  tableau interactif. Retour imm√©diat sur chaque action.

‚Ä¢ D√âPLOIEMENT SIMPLIFI√â
  Scripts automatis√©s pour d√©marrer/arr√™ter le syst√®me complet en une commande.
  Pas de configuration manuelle complexe.

‚Ä¢ √âVOLUTIVIT√â
  L'architecture REST permet facilement d'ajouter de nouveaux services
  (paiement, notifications, etc.) sans modifier l'existant.



== Utilisation

D√âMARRAGE RAPIDE

1. Premier lancement (BDD vide) :
   ./rest-all-restart.sh

2. Relancement avec donn√©es existantes :
   ./rest-restart.sh

3. Lancement du client seul :
   ./rest-client.sh

4. Arr√™t complet :
   ./arreter-services.sh

Le syst√®me est op√©rationnel en environ 30 secondes.


WORKFLOW UTILISATEUR TYPE

1. Lancement de l'interface graphique
2. V√©rification de la connexion (barre de statut)
3. Saisie des crit√®res de recherche
4. Consultation des r√©sultats (toutes agences confondues)
5. Visualisation des images des chambres
6. R√©servation par double-clic
7. Confirmation avec num√©ro de r√©servation
8. Consultation des r√©servations


== Synth√®se


Le projet impl√©mente un syst√®me complet et fonctionnel de r√©servation
h√¥teli√®re avec une architecture REST moderne et distribu√©e.

La migration de SOAP vers REST a √©t√© r√©ussie, apportant :
  ‚Ä¢ Simplicit√© des communications (JSON vs XML)
  ‚Ä¢ Standardisation (m√©thodes HTTP)
  ‚Ä¢ Performance (messages plus l√©gers)
  ‚Ä¢ Compatibilit√© universelle

L'ajout de la persistance H2 garantit la fiabilit√© des donn√©es et permet
une utilisation en conditions r√©elles.

L'interface graphique Swing offre une exp√©rience utilisateur compl√®te et
intuitive, avec retour visuel sur chaque op√©ration.

Le syst√®me est pr√™t pour une utilisation en production, avec des √©volutions
possibles clairement identifi√©es (s√©curit√©, performance, fonctionnalit√©s).

= Diagramme et S√©quence

== Diagramme du projet en g√©n√©rale
#figure(
  image("Image/REST_Gen.png"),
)
== Diagramme S√©quentielle sur la recherche

#figure(
  image("Image/REST_Recherche.png"),
)

== Diagramme S√©quentielle sur la r√©servation
#figure(
  image("Image/REST_Reserv.png"),
)